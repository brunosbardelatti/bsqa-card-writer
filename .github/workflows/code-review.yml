name: AI Code Review

on:
  pull_request:
    types: [opened, synchronize, reopened]

permissions:
  contents: read
  pull-requests: write

jobs:
  ai-review:
    runs-on: ubuntu-latest
    env:
      GH_TOKEN: ${{ github.token }}

    steps:
      - name: üîÑ Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: üì¶ Instalando depend√™ncias necess√°rias
        run: |
          echo "üì¶ Instalando depend√™ncias necess√°rias..."
          if ! command -v jq &> /dev/null; then
            echo "Instalando jq..."
            sudo apt update
            sudo apt install -y jq
          else
            echo "‚úÖ jq j√° est√° instalado"
          fi

          if ! command -v gh &> /dev/null; then
            echo "Instalando GitHub CLI..."
            curl -fsSL https://cli.github.com/packages/githubcli-archive-keyring.gpg | sudo dd of=/usr/share/keyrings/githubcli-archive-keyring.gpg
            echo "deb [arch=$(dpkg --print-architecture) signed-by=/usr/share/keyrings/githubcli-archive-keyring.gpg] https://cli.github.com/packages stable main" | sudo tee /etc/apt/sources.list.d/github-cli.list > /dev/null
            sudo apt update
            sudo apt install -y gh
          else
            echo "‚úÖ GitHub CLI j√° est√° instalado"
          fi
          echo "‚úÖ Todas as depend√™ncias foram verificadas"

      - name: üîç Gerando Diff
        run: |
          echo "Fetching base branch..."
          git fetch origin ${{ github.base_ref }}
          echo "Generating diff..."
          git diff origin/${{ github.base_ref }}...HEAD > diff.txt

          if [ ! -f diff.txt ] || [ ! -s diff.txt ]; then
            echo "‚ùå Erro: N√£o foi poss√≠vel gerar o diff ou o diff est√° vazio"
            echo "No changes to review" > diff.txt
          fi

          DIFF_SIZE=$(wc -c < diff.txt)
          if [ $DIFF_SIZE -gt 51200 ]; then
            echo "‚ö†Ô∏è Diff muito grande ($DIFF_SIZE bytes), truncando..."
            head -c 51200 diff.txt > diff_truncated.txt
            echo -e "\n\n... [DIFF TRUNCADO - MUITAS ALTERA√á√ïES] ..." >> diff_truncated.txt
            mv diff_truncated.txt diff.txt
          fi

          echo "=== DIFF FILE PREVIEW ==="
          head -n 20 diff.txt

      - name: üîê Gerando Token StackSpot
        run: |
          echo "üîê Iniciando autentica√ß√£o StackSpot..."
          echo "‚è∞ Timestamp: $(date -u '+%Y-%m-%d %H:%M:%S UTC')"
          START_TIME=$SECONDS
          TOKEN_RESPONSE=$(curl --fail --show-error --max-time 30 --retry 2 -s --location 'https://idm.stackspot.com/stackspot-freemium/oidc/oauth/token' \
            --header 'Content-Type: application/x-www-form-urlencoded' \
            --data-urlencode "client_id=${{ secrets.STACKSPOT_CLIENT_ID }}" \
            --data-urlencode 'grant_type=client_credentials' \
            --data-urlencode "client_secret=${{ secrets.STACKSPOT_CLIENT_SECRET }}") || {
            echo "‚ùå Erro: Falha na requisi√ß√£o para o StackSpot"
            echo "üîç Poss√≠veis causas:"
            echo "  - Timeout de rede (>30s)"
            echo "  - Endpoint StackSpot indispon√≠vel"
            echo "  - Credenciais inv√°lidas (HTTP 401/403)"
            echo "  - Erro de conectividade"
            exit 1
          }

          # Validar se a resposta √© JSON v√°lido
          if ! echo "$TOKEN_RESPONSE" | jq . > /dev/null 2>&1; then
            echo "‚ùå Erro: Resposta n√£o √© JSON v√°lido"
            echo "üîç Poss√≠vel resposta em texto plano ou HTML de erro"
            exit 1
          fi

          # Verificar se h√° erro na resposta do StackSpot
          if echo "$TOKEN_RESPONSE" | jq -e '.error' > /dev/null 2>&1; then
            ERROR_TYPE=$(echo "$TOKEN_RESPONSE" | jq -r '.error')
            ERROR_DESC=$(echo "$TOKEN_RESPONSE" | jq -r '.error_description // "Sem descri√ß√£o"')
            echo "‚ùå Erro de autentica√ß√£o StackSpot: $ERROR_TYPE"
            echo "üìù Descri√ß√£o: $ERROR_DESC"
            echo "üîç Verifique as credenciais nos secrets do reposit√≥rio"
            exit 1
          fi

          # Verificar se access_token est√° presente
          if echo "$TOKEN_RESPONSE" | jq -e '.access_token' > /dev/null 2>&1; then
            ACCESS_TOKEN=$(echo "$TOKEN_RESPONSE" | jq -r '.access_token')
            # Validar se o token n√£o est√° vazio
            if [ -z "$ACCESS_TOKEN" ] || [ "$ACCESS_TOKEN" = "null" ]; then
              echo "‚ùå Erro: Access token est√° vazio ou nulo"
              exit 1
            fi
            # Mascarar o token nos logs para seguran√ßa
            echo "::add-mask::$ACCESS_TOKEN"
            echo "ACCESS_TOKEN=$ACCESS_TOKEN" >> $GITHUB_ENV
            echo "‚úÖ Autentica√ß√£o bem-sucedida - Token obtido e mascarado"
            echo "‚è±Ô∏è Dura√ß√£o da autentica√ß√£o: $((SECONDS - START_TIME))s" || echo "‚è±Ô∏è Tempo de autentica√ß√£o registrado"
          else
            echo "‚ùå Erro: Campo 'access_token' n√£o encontrado na resposta"
            echo "üîç Verifique se as credenciais est√£o corretas e se o endpoint retorna a estrutura esperada"
            exit 1
          fi

      - name: ü§ñ Chamando StackSpot AI para revis√£o
        run: |
          echo "ü§ñ Iniciando an√°lise de c√≥digo com StackSpot AI..."
          echo "‚è∞ Timestamp: $(date -u '+%Y-%m-%d %H:%M:%S UTC')"
          AI_START_TIME=$SECONDS

          {
            echo "You are a senior code reviewer."
            echo
            echo "You will receive a raw Git diff via {requirements}."
            echo
            echo "**Your task:**"
            echo
            echo "1. Analyze the diff and automatically detect the programming language or framework (e.g., Python, Robot Framework, Node.js, PHP)."
            echo "   - Apply **best practices, linting rules, conventions and security guidelines** specific to the detected technology."
            echo
            echo "2. Provide a **code review in Portuguese (Brazil)** with the following structure:"
            echo "   - **Feedback por Arquivo**: List only the files where there are **problems, issues, or relevant improvement points**."
            echo "     - Show **only the problematic snippets** using code blocks (\`\`\`), explaining **what is wrong or can be improved**."
            echo "     - Provide **objective correction/refactoring suggestions**."
            echo "     - **Explain the practical impact of each issue or suggestion** (e.g., \"isso pode causar falhas intermitentes nos testes\")."
            echo "     - Include **Opini√µes** only when they are optional adjustments that improve clarity, performance, or standardization."
            echo "     - Check for hardcoded values (e.g., API keys, agent IDs, secrets, URLs, tokens, or credentials) and flag them as security risks."
            echo
            echo "3. **Classifica√ß√£o de Achados**"
            echo "   - **Cr√≠ticos** ‚Äì Bugs, logical errors, hardcoded sensitive data, or security vulnerabilities."
            echo "   - **Melhorias** ‚Äì Refactorings, best practices, performance, linting."
            echo
            echo "4. **Resumo Final**"
            echo "   - Return **APROVADO** if no critical issues are found."
            echo "   - Return **REPROVADO** if critical issues are detected."
            echo "   - List only the relevant action points."
            echo
            echo "---"
            echo
            echo "**Important Rules:**"
            echo "- Do not describe correct or trivial changes."
            echo "- Provide only **useful technical feedback** (critical issues or real improvements)."
            echo "- Always explain the practical impact of problems or improvements."
            echo "- Pay special attention to hardcoded values or secrets, recommending the use of environment variables or repository secrets."
            echo "- Do not include the technology detection section in the response."
            echo "- Use markdown (\`\`\`) to show code snippets when necessary."
            echo "- If a file contains the comment `excludeFromCodeCoverage`, completely skip the analysis and code review for that specific file."
            echo "- If there are no issues, finish with a brief positive summary and **APROVADO**."
            echo "- If there are problems, finish with a brief summary and **REPROVADO**."
            echo "<DIFF_START>"
            cat diff.txt
            echo "<DIFF_END>"
          } > prompt.txt

          PROMPT_CONTENT=$(cat prompt.txt)

          echo "üìù Prompt preparado com $(wc -l < prompt.txt) linhas"
          echo "üîç Visualizando primeiras 40 linhas do prompt:"
          head -n 40 prompt.txt

          echo "üöÄ Enviando requisi√ß√£o para StackSpot AI..."
          echo "üìä Tamanho do prompt: $(wc -c < prompt.txt) caracteres"
          
          echo "üîß Criando payload JSON sem escape de caracteres..."
          
          # Criar script Python tempor√°rio
          cat > create_payload.py << 'EOF'
import json
import sys

# Ler o prompt do arquivo
with open('prompt.txt', 'r', encoding='utf-8') as f:
    prompt_content = f.read()

# Criar payload JSON
payload = {
    "streaming": False,
    "user_prompt": prompt_content,
    "stackspot_knowledge": False,
    "return_ks_in_response": False
}

# Salvar JSON no arquivo
with open('payload.json', 'w', encoding='utf-8') as f:
    json.dump(payload, f, ensure_ascii=False, separators=(',', ':'))

print(f"‚úÖ Payload JSON criado. Tamanho: {len(json.dumps(payload, ensure_ascii=False))} caracteres")

# Debug: mostrar primeiras linhas do prompt que foi processado
print("üîç DEBUG - Primeiras 10 linhas do prompt enviado:")
lines = prompt_content.split('\n')
for i, line in enumerate(lines[:10]):
    print(f"  {i+1}: {line}")
EOF

          # Executar o script Python
          if ! python3 create_payload.py; then
            echo "‚ùå Erro ao executar script Python para criar payload"
            echo "üîç Verificando se o arquivo prompt.txt existe..."
            if [ ! -f prompt.txt ]; then
              echo "‚ùå Arquivo prompt.txt n√£o encontrado"
              exit 1
            fi
            echo "üìÑ Tamanho do prompt.txt: $(wc -c < prompt.txt) caracteres"
            echo "üîç Primeiras 5 linhas do prompt.txt:"
            head -n 5 prompt.txt
            exit 1
          fi
          
          # Verificar se o payload.json foi criado corretamente
          if [ ! -f payload.json ]; then
            echo "‚ùå Arquivo payload.json n√£o foi criado"
            exit 1
          fi
          
          PAYLOAD_SIZE=$(wc -c < payload.json)
          if [ "$PAYLOAD_SIZE" -lt 100 ]; then
            echo "‚ùå Arquivo payload.json muito pequeno ($PAYLOAD_SIZE bytes), pode estar corrompido"
            echo "üîç Conte√∫do do payload.json:"
            cat payload.json
            exit 1
          fi
          
          echo "‚úÖ Payload JSON validado com sucesso ($PAYLOAD_SIZE bytes)"
          
          # Executar requisi√ß√£o com tratamento de erro melhorado
          set +e  # Desabilitar exit on error temporariamente
          RESPONSE=$(curl -s -w "\n###STATUS###%{http_code}" --max-time 60 --retry 1 --location "https://genai-inference-app.stackspot.com/v1/agent/${{ secrets.STACKSPOT_AGENT_ID }}/chat" --header 'Content-Type: application/json' --header "Authorization: Bearer $ACCESS_TOKEN" --data @payload.json)
          CURL_EXIT_CODE=$?
          set -e  # Reabilitar exit on error
          
          if [ $CURL_EXIT_CODE -ne 0 ]; then
            echo "‚ùå Erro na requisi√ß√£o curl (c√≥digo: $CURL_EXIT_CODE)"
            case $CURL_EXIT_CODE in
              6) echo "üîç Erro: N√£o foi poss√≠vel resolver o host" ;;
              7) echo "üîç Erro: Falha ao conectar com o servidor" ;;
              28) echo "üîç Erro: Timeout (>60s)" ;;
              *) echo "üîç Erro curl n√£o identificado. Verifique conectividade." ;;
            esac
            exit 1
          fi

          # Debug: Verificar se a resposta n√£o est√° vazia
          if [ -z "$RESPONSE" ]; then
            echo "‚ùå Resposta vazia da API StackSpot"
            exit 1
          fi

          # Extrair status HTTP corretamente
          HTTP_STATUS=$(echo "$RESPONSE" | tail -n 1 | sed 's/.*###STATUS###//')
          RESPONSE_BODY=$(echo "$RESPONSE" | sed '$d')

          # Debug tempor√°rio
          echo "üîç DEBUG - Tamanho da resposta: ${#RESPONSE} caracteres"
          echo "üîç DEBUG - Status HTTP extra√≠do: '$HTTP_STATUS'"

          # Validar se status HTTP √© num√©rico
          if ! [[ "$HTTP_STATUS" =~ ^[0-9]+$ ]]; then
            echo "‚ùå Erro: Status HTTP n√£o √© num√©rico: '$HTTP_STATUS'"
            echo "üîç √öltimas 5 linhas da resposta completa:"
            echo "$RESPONSE" | tail -n 5
            exit 1
          fi

          echo "üì° Status HTTP da resposta: $HTTP_STATUS"
          if [ "$HTTP_STATUS" != "200" ]; then
            echo "‚ùå Erro na requisi√ß√£o StackSpot (HTTP $HTTP_STATUS)"
            echo "üîç Verifique se o token est√° v√°lido e se o agente est√° dispon√≠vel"
            echo "‚è±Ô∏è Tempo at√© falha: $((SECONDS - AI_START_TIME))s"
          else
            echo "‚úÖ Requisi√ß√£o StackSpot executada com sucesso"
            echo "‚è±Ô∏è Tempo de resposta da API: $((SECONDS - AI_START_TIME))s"
          fi

          # Debug: Mostrar in√≠cio do response body
          echo "üîç DEBUG - Primeiros 200 caracteres do response body:"
          echo "$RESPONSE_BODY" | head -c 200
          echo ""

          # Validar se response body √© JSON v√°lido
          if ! echo "$RESPONSE_BODY" | jq . > /dev/null 2>&1; then
            echo "‚ùå Response body n√£o √© JSON v√°lido"
            echo "üìÑ Conte√∫do recebido:"
            echo "$RESPONSE_BODY" | head -c 500
            exit 1
          fi

          # Extrair resposta da IA
          REVIEW_OUTPUT=$(echo "$RESPONSE_BODY" | jq -r '.message // .output_text // empty')
          
          # Debug: Verificar extra√ß√£o
          echo "üîç DEBUG - REVIEW_OUTPUT extra√≠do: ${#REVIEW_OUTPUT} caracteres"
          
          if [ -z "$REVIEW_OUTPUT" ] || [ "$REVIEW_OUTPUT" = "null" ]; then
            echo "‚ùå Falha ao extrair resposta da IA"
            echo "üìã Tentando extrair diretamente da resposta JSON:"
            # Fallback: tentar extrair de outras formas
            REVIEW_OUTPUT=$(echo "$RESPONSE_BODY" | jq -r '.message' 2>/dev/null) || \
            REVIEW_OUTPUT=$(echo "$RESPONSE_BODY" | jq -r '.output_text' 2>/dev/null) || \
            REVIEW_OUTPUT="‚ö†Ô∏è Falha na an√°lise de c√≥digo por IA - verifique manualmente"
          fi

          # Salvar resultado final
          echo "$REVIEW_OUTPUT" > review.txt
          REVIEW_LENGTH=$(echo "$REVIEW_OUTPUT" | wc -c)
          
          if [ "$REVIEW_LENGTH" -gt 50 ]; then
            echo "‚úÖ An√°lise da IA conclu√≠da com sucesso"
            echo "üìä Tamanho da resposta: $REVIEW_LENGTH caracteres"
          else
            echo "‚ö†Ô∏è Resposta da IA muito curta, pode ter havido problema"
          fi

          echo "üìã Conte√∫do da revis√£o gerada:"
          echo "----------------------------------------"
          cat review.txt
          echo "----------------------------------------"

      - name: üí¨ Adicionando coment√°rio ao PR
        run: |
          echo "üí¨ Preparando coment√°rio para o PR..."
          echo "üéØ PR #${{ github.event.pull_request.number }}: ${{ github.head_ref }} ‚Üí ${{ github.base_ref }}"
          echo "## ü§ñ Revis√£o Autom√°tica de C√≥digo - StackSpot AI" > final_review.txt
          echo "" >> final_review.txt
          echo "**PR:** #${{ github.event.pull_request.number }}" >> final_review.txt
          echo "**Branch:** \`${{ github.head_ref }}\` ‚Üí \`${{ github.base_ref }}\`" >> final_review.txt
          echo "**Commit:** ${{ github.sha }}" >> final_review.txt
          echo "" >> final_review.txt
          echo "---" >> final_review.txt
          echo "" >> final_review.txt
          cat review.txt >> final_review.txt
          echo "" >> final_review.txt
          echo "---" >> final_review.txt
          echo "*Revis√£o gerada automaticamente em $(date -u '+%Y-%m-%d %H:%M:%S UTC')*" >> final_review.txt

          echo "üì§ Enviando coment√°rio para o PR..."
          gh pr comment ${{ github.event.pull_request.number }} --body-file final_review.txt && {
            echo "‚úÖ Coment√°rio adicionado com sucesso ao PR #${{ github.event.pull_request.number }}"
          } || {
            echo "‚ùå Erro ao adicionar coment√°rio ao PR"
            echo "üìÑ Conte√∫do que tentou ser enviado:"
            cat final_review.txt
            exit 1
          }

      - name: ‚õî Validando resultado da IA
        run: |
          echo "üîç Validando resultado da an√°lise de c√≥digo..."
          if [ ! -f review.txt ]; then
            echo "‚ö†Ô∏è Arquivo review.txt n√£o encontrado!"
            exit 1
          fi

          # Debug: Mostrar tamanho e in√≠cio do arquivo de review
          REVIEW_SIZE=$(wc -c < review.txt)
          echo "üîç DEBUG - Tamanho do arquivo review.txt: $REVIEW_SIZE caracteres"
          echo "üîç DEBUG - Primeiras 3 linhas do review.txt:"
          head -n 3 review.txt

          # Verificar se cont√©m palavra REPROVADO
          if grep -q "REPROVADO" review.txt; then
            echo "‚ùå RESULTADO: REPROVADO"
            echo "üö® A revis√£o da IA encontrou problemas cr√≠ticos."
            echo "üìã O job ser√° falhado para bloquear o merge."
            exit 1
          elif grep -q "APROVADO" review.txt; then
            echo "‚úÖ RESULTADO: APROVADO"
            echo "üéâ A revis√£o da IA aprovou as altera√ß√µes."
            echo "üöÄ O PR pode prosseguir para merge."
          else
            echo "‚ö†Ô∏è RESULTADO: INDETERMINADO"
            echo "üîç N√£o foi poss√≠vel determinar se foi aprovado ou reprovado"
            echo "üìã Conte√∫do do review ser√° inclu√≠do no coment√°rio do PR"
            echo "‚ö° Assumindo aprova√ß√£o para n√£o bloquear o fluxo"
          fi

      - name: üßπ Limpeza
        if: always()
        run: |
          echo "üßπ Iniciando limpeza de arquivos tempor√°rios..."
          FILES_TO_CLEAN="diff.txt prompt.txt review.txt final_review.txt payload.json create_payload.py"
          for file in $FILES_TO_CLEAN; do
            if [ -f "$file" ]; then
              rm -f "$file"
              echo "üóëÔ∏è Removido: $file"
            fi
          done
          echo "‚úÖ Limpeza conclu√≠da com sucesso"